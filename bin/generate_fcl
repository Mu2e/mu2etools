#!/usr/bin/perl -w
#
# A.Gaponenko, 2015
#

use autodie;
use Getopt::Long;
use File::Basename;
use File::Copy;
use File::Temp qw/tempfile/;
use English qw( -no_match_vars ) ; # Avoids regex performance penalty

use Data::Dumper; # for debugging

use Class::Struct Mu2eFileName =>
    [tier=>'$', owner=>'$', description=>'$', configuration=>'$', sequencer=>'$', extension=>'$' ];

# information from an --auxinput specification (same as mu2eart's --fclin spec)
# listFileName is the name of the file specified on cmdline,
# filenames is the content of that file
# prolog==1 requests to place fcl defs in a BEGIN_PROLOG/END_PROLOG block.
use Class::Struct Mu2eAuxInSpec =>
    [numFilesPerJob=>'$', fclkey=>'$', prolog=>'$', filenames=>'*@', listFileName=>'$'];

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage:
        $self \\
         --description=<string> --dsconf=<string> \\
         [--dsowner=<string>] \\
         --generator-type=<string> \\
         --simulation-stage=<int> \\
         --primary-particle=<string> \\
         { --inputs=<list-file-name> --merge-factor=<int> |\\
           --run-number=<int> --first-subrun=<int> \\
           --events-per-job=<int> --njobs=<int> }\\
         [--old-seeds=<seeds-file-name>] \\
         [--auxinput=[numFiles:]<fclVarName>:<filelist>] \\
         [--verbose] [--help] \\
         template-fcl-file

That will write --njobs fcl files to the current directory.  File
names will be constructed using --description, --dsconf, and
other pieces of information according to the Mu2e convention
http://mu2e.fnal.gov/atwork/computing/tapeUpload.shtml
Note that the name of each file in the Mu2e data handling system must
be unique. If --dsowner is not specified, the current username
will be used.

The --old-seeds option points to a text file with a list of seeds that
should not be used in the current generation.  It is required in case
the fcl file defines services.user.SeedService.  Normally this file
will contain a list of seeds in already existing subruns of this
dataset.  One can specify /dev/null for the initial generation.

The --auxinput option sets the given fcl file variable so that it
points to the files in the given filelist.  If numFiles is specified,
only the given number of randomly selected files from the list are
used, rather than the complete list.  The --fclinput option can be
repeated several times, the effect is cumulative.

The square brackets [] above denote optional settings, and
{alternative1|alternative2} constructs denote mutually exclusive
alternatives.  All option names may be abbreviates as long as this is
unambiguous.  (For example, '--verbose' and '--verb' mean the same
thing.)

EOF
}

#notimpl: The --auxinput option sets the given fcl file variable so that it
#notimpl: points to the files in the given filelist.  If numFiles is specified,
#notimpl: only the given number of randomly selected files from the list are
#notimpl: used, rather than the complete list.  The --fclinput option can be
#notimpl: repeated several times, the effect is cumulative.  If fclVarName
#notimpl: starts with the '\@' sign, it will generate a BEGIN_PROLOG/END_PROLOG
#notimpl: block with a fclVarName definition, which should be referred to using
#notimpl: the \@local::fclVarName syntax in the template fcl file.  If the
#notimpl: variable name does not start with the '\@' sign, an assignment to that
#notimpl: variable will be appended to the user fcl file.



#================================================================
# constant strings used in more than one place

use constant fclkey_SeedService => 'services.user.SeedService';
use constant fclkey_TFileServiceFN => 'services.TFileService.fileName';
use constant fclkey_outModFMT => 'outputs.%s.fileName';

use constant outputfile_owner => 'MU2EGRIDDSOWNER';
use constant outputfile_conf => 'MU2EGRIDDSCONF';

#================================================================
sub doubleQuote($) {
    my ($fn) = @_;
    return  '"'.$fn.'"';
}

#================================================================
sub parseMu2eFileName($) {
    my ($fn) = @_;

    my ($tier, $owner, $description, $conf, $seq, $ext, $extra) = split(/\./, basename($fn));

    die "Error parsing Mu2e file name $fn: too many fields\n" if defined $extra;
    die "Error parsing Mu2e file name $fn: too few fields\n" if not defined $ext;

    return Mu2eFileName->new(
        tier=>$tier,
        owner=>$owner,
        description=>$description,
        configuration=>$conf,
        sequencer=>$seq,
        extension=>$ext,
        );
}

#================================================================
sub checkParameterValues($$) {
    my ($opt, $list) = @_;
    foreach my $a (@$list) {
        die "Error: parameter $a must be specified\n" unless defined $$opt{$a};
        my $val = $$opt{$a};
        die "Invalid value of parameter $a = '$val'"
            unless $val =~ /^\w[-\w]*$/;
    }
}

sub makeNtsFileName($$) {
    my ($template, $newseq) = @_;
    my $fn = parseMu2eFileName($template);

    die "Error parsing histo file name $template: expect extension .root\n" unless $fn->extension eq 'root';
    die "Error parsing histo file name $template: expect data tier nts\n" unless $fn->tier eq 'nts';

    return join('.', ('nts', outputfile_owner, $fn->description, outputfile_conf, $newseq, 'root') );
}

sub makeArtFileName($$) {
    my ($template, $newseq) = @_;

    my $fn = parseMu2eFileName($template);

    die "Error parsing histo file name $template: expect extension .art\n" unless $fn->extension eq 'art';
    die "Error parsing art file name $template: unknown data tier ",$fn->tier,"\n"
        unless grep( m'^'.$fn->tier.'$', ('sim', 'mix', 'dig', 'mcs') );

    return join('.', ($fn->tier, outputfile_owner, $fn->description, outputfile_conf, $newseq, 'art') );
}

#================================================================
sub addEventID($$$$) {
    my ($fh, $run, $subrun, $maxEvents) = @_;
    print $fh
        "source.firstRun: $run\n",
        "source.firstSubRun: $subrun\n",
        "source.maxEvents: $maxEvents\n"
        or die "addEventID(): error printing to output file: $!\n";
}

sub addRandomSeed($$) {
    my ($fh, $usedSeeds) = @_;
    my $maxUniqueEngines = 20;

    # art's RandomNumberGenerator_service restrict seeds to
    # not exceed 900000000.   Not clear if zero seed is OK
    # so we'll use a non-negative number up to the max.
    # Should leave space for SeedService to increment, thus
    # need to account for maxUniqueEngines.
    my $seedlimit= 900000000 - $maxUniqueEngines + 1;

    open(my $rndfh, '<', '/dev/urandom') or die "Error opening input file /dev/urandom: $!\n";

    my $seed=0;
    while(!$seed) {
        my $recsize = 4; # bytes
        my $binseed = 0;
        read($rndfh, $binseed, $recsize) == $recsize or die "Error reading from /dev/urandom: $!\n";
        my $inseed = unpack '%32L', $binseed;
        $seed = $inseed % $seedlimit;

        if($$usedSeeds{$seed}) {
            print STDERR "Skipping old seed $seed\n";
            redo;
        }
    }
    $$usedSeeds{$seed} = 1;

    print $fh
        fclkey_SeedService . ".policy:  autoIncrement\n",
        fclkey_SeedService . ".maxUniqueEngines: $maxUniqueEngines\n",
        fclkey_SeedService . ".baseSeed: $seed\n"
        or die "Error printing to output file: $!\n";
}

#================================================================
sub sampleFileNames($) {
    my ($spec) = @_;

    my $res = [];

    my %usedIndexes;

    if($spec->numFilesPerJob > 0) {
        die "--auxin requests too many files = ",$spec->numFilesPerJob,
        " for file list ",$spec->listFileName,"\n"
            unless $spec->numFilesPerJob < 1+$#{$spec->filenames};

        for(my $i=0; $i<$spec->numFilesPerJob; ) {
            my $index = int(rand($#{$spec->filenames}));
            if(not defined $usedIndexes{$index}) {
                push @$res, ${$spec->filenames}[$index];
                $usedIndexes{$index} = 1;
                ++$i;
            }
        }
    }
    else {
        # use all files from the input list - no sampling
        push @$res, @{$spec->filenames};
    }

    return $res;
}

#================================================================
sub getNextInputListChunk($$) {
    my ($inputfh, $chunkSize) = @_;
    my @res;
    my $line;
    for(my $count=0; ($count < $chunkSize) and ($line = <$inputfh>); ++$count) {
        chomp($line);
        die "Input file list error: the line is empty or contains white spaces or other non-printable characters: \"$line\"\n"
            unless $line =~ /^\p{IsGraph}+$/;
        push @res, $line;
    }
    return @res;
}

#================================================================
sub extractASequencer($) {
    my ($fnlist) = @_;

    die "extractASequencer() got empty inputs\n"
        unless $#$fnlist > -1;

    my @seqs;
    foreach my $fn (@$fnlist) {
        my  $p = parseMu2eFileName($fn);
        push @seqs,$p->sequencer;
    }

    return (sort @seqs)[0];
}
#================================================================
sub addInputFileNames($$$) {
    my ($fh, $fclkey, $listref) = @_;
    print $fh "$fclkey: [\n", join(",\n", map  { doubleQuote($_) } @$listref ) ,"\n]\n"
        or die "addInputFileNames(): error printing to output file: $!\n";
    return $fclkey;
}

#================================================================
sub addAuxInPrologs($$) {
    my ($fh, $specs) = @_;

    foreach my $ai (@$specs) {
        if($ai->prolog) {
            my $sample = sampleFileNames($ai);
            print $fh "BEGIN_PROLOG  # by generate_fcl\n"
                or die "addAuxInPrologs() BEGIN: error printing to output file: $!\n";
            addInputFileNames($fh, $ai->fclkey, $sample);
            print $fh "END_PROLOG  # by generate_fcl\n\n"
                or die "addAuxInPrologs() END: error printing to output file: $!\n";
        }
    }
}
#================================================================
# fhicl-getpar allows worker node script to query parameter values.
# The names of @local variables are not directly accessible there, we
# need to create a fcl parameter for each @local var in order to get
# information about parents.
sub generateKeysForLocals($$) {
    my ($fh, $specs) = @_;
    my @fclkeys;
    foreach my $ai (@$specs) {
        if($ai->prolog) {
            my $key = 'mu2emetadata.fcl.inkey_values.' . $ai->fclkey;
            print $fh $key . ': @local::' . $ai->fclkey . "\n"
                or die "generateKeysForLocals(): error printing to output file: $!\n";
            push @fclkeys, $key;
        }
    }
    return @fclkeys;
}

#================================================================
sub addAuxInEpilogs($$) {
    my ($fh, $specs) = @_;

    my @fclinkeys;
    foreach my $ai (@$specs) {
        if(!$ai->prolog) {
            my $sample = sampleFileNames($ai);
            push @fclinkeys, addInputFileNames($fh, $ai->fclkey, $sample);
        }
    }
    return @fclinkeys;
}

#================================================================
# execution starts here
my $defaultUser = getpwuid($EFFECTIVE_USER_ID);
my @auxinputStrSpecs;
my %opt = ('dsowner' =>  $defaultUser, 'auxinput' => \@auxinputStrSpecs, 'verbose' => 0, 'help' => 0);

# Process command line opts.
GetOptions(\%opt,
           'description=s',
           'dsconf=s',
           'dsowner=s',
           'generator-type=s',
           'simulation-stage=i',
           'primary-particle=s',
           'inputs=s',
           'merge-factor=i',
           'run-number=i',
           'first-subrun=i',
           'events-per-job=i',
           'njobs=i',
           'old-seeds=s',
           'auxinput=s',
           'help',
           'verbose',
    )
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

my $verbose = $opt{'verbose'};
print "Final set of options:\n", Dumper( \%opt ), "\n"
    if($verbose);

die "A single non-option arg must specify a template file. Try the --help option.\n"
    unless $#ARGV == 0;

my $templatefile = $ARGV[0];

#----------------------------------------------------------------
# Set up the environment and extract info from the input fcl file
$ENV{'FHICL_FILE_PATH'} =
    defined($ENV{'FHICL_FILE_PATH'}) ?
    ".:$ENV{'FHICL_FILE_PATH'}"
    : ".";

my $srctype = `fhicl-getpar --string source.module_type $templatefile`;
if($?) {
    die "Error running fhicl-getpar to determine source.module_type.\n";
}
chomp $srctype;
print "Got srctype = $srctype\n" if $verbose;

# optional TFileService output
my $ntscmd = "fhicl-getpar --string ".fclkey_TFileServiceFN." $templatefile 2>/dev/null";
my $ntsout = `$ntscmd`;
chomp $ntsout;
print "Got ntsout = $ntsout\n" if $verbose;

# optional .art output files
my @outmods = `fhicl-getpar --keys outputs $templatefile 2>/dev/null`;
chomp @outmods;
print "Got outmods = @outmods\n" if $verbose;
my %fwout;
foreach my $mod (@outmods) {
    my $cmd = sprintf "fhicl-getpar --string ".fclkey_outModFMT." $templatefile 2>/dev/null", $mod;
    my $outfile = `$cmd`;
    if($?) {
        die "Error: no fileName for outputs.$mod\n";
    }
    chomp $outfile;;
    $fwout{$mod} = $outfile;
    print "$mod => $outfile\n" if $verbose;
}

# Determine whether SeedService is present: should we generate random seeds?
my $seedcmd = "fhicl-getpar --keys ".fclkey_SeedService." $templatefile 2>/dev/null";
my @seedout = `$seedcmd`; chomp @seedout;
my $needRandomSeeds = $? ? 0 : 1;
print "needRandomSeeds = $needRandomSeeds because got @seedout\n" if $verbose;

my %usedSeeds;
if($needRandomSeeds) {
    die "A list of random seeds from existing subruns of this dataset must be specified with --old-seeds.\n"
        ."Use an empty file for the initial run.\n"
        unless defined $opt{'old-seeds'};

    open(my $oldseeds, '<', $opt{'old-seeds'}) or die "Error opening input file $opt{'old-seeds'}: $!\n";
    while(my $line = <$oldseeds>) {
        chomp $line;
        next if $line eq '';
        die "Error: bad seed '$line'\n" unless $line =~ /^\d+$/;
        $usedSeeds{0 + $line} = 1;
    }
}
elsif(defined $opt{'old-seeds'}) {
    die "Error: the --old-seeds option will not have any effect because fcl config does not use " . fclkey_SeedService . "\n";
}

#----------------
# Handle the --auxinput options

my @auxin_specs;
foreach my $str (@auxinputStrSpecs) {

    die "Error in an --auxin specification: no ':' in $str\n" unless $str =~ /:/;

    my $numFiles = 0; # the default: unlimited
    my $var;
    my $listfile;
    (my $l1, my $l2) = split(/:/, $str, 2);
    if($l1 =~ /^\d/) {
        die "Invalid numFiles=$l1  in --auxinput=$str\n"
            unless $l1 =~ /^\d+$/;
        $numFiles = $l1;
        die "Error in an --auxin specification: no 'filelist' part in $str\n" unless $l2 =~ /:/;
        ($var, $listfile) = split(/:/, $l2, 2);
    }
    else {
        ($var, $listfile) = ($l1, $l2);
    }

    my @auxfiles;
    open(my $fh, '<', $listfile) or die "Can not open for reading file \"$listfile\": $!\n";
    while(my $line = <$fh>) {
        chomp($line);
        die "Error in file $listfile: the line is empty or contains white spaces or other non-printable characters: \"$line\"\n"
            unless $line =~ /^\p{IsGraph}+$/;

        # Must be a Mu2e file name, as it will become an parent in the
        # provenance record of our output datasets.
        parseMu2eFileName($line);

        push @auxfiles, $line;
    }

    my $prolog = 0;
    $prolog = 1 if($var =~ s/^\@// );

    die "File lists in \@local fhicl variables are not supported by worker node scripts.\n"
        if $prolog;

    my $spec = Mu2eAuxInSpec->new(
        numFilesPerJob=>$numFiles,
        fclkey=>$var,
        prolog=>$prolog,
        filenames=>\@auxfiles,
        listFileName=>$listfile,
        );

    push @auxin_specs, $spec;
}

#================================================================
# These arguments must always be provided

checkParameterValues(\%opt,
                     ['dsowner',
                      'dsconf',
                      'description',
                      'generator-type',
                      'simulation-stage',
                      'primary-particle'
                     ]);

my $dsowner = $opt{'dsowner'};
my $dsconf = $opt{'dsconf'};

my $generator_type = $opt{'generator-type'};
my $simulation_stage = $opt{'simulation-stage'};
my $primary_particle = $opt{'primary-particle'};

# The set of required args depends on the fcl: e.g s1 needs run
# and subrun numbers but s2 does not, and can not use them.

my @emptySourceArgs = ('run-number', 'first-subrun', 'events-per-job', 'njobs');
my @fileInputsArgs = ('inputs', 'merge-factor');

#================================================================
sub setOutputFileNames($$) {
    my ($fh, $seq) = @_;

    my @fcloutkeys; # fcl keys for all output file name

    my $histval = makeNtsFileName($ntsout, $seq);
    print $fh  fclkey_TFileServiceFN .": \"$histval\"\n"
        or die "setOutputFileNames(): error printing to output file: $!\n";

    push @fcloutkeys, fclkey_TFileServiceFN
        or die "setOutputFileNames(): error printing to output file: $!\n";

    foreach my $mod (@outmods) {
        my $artkey = sprintf fclkey_outModFMT, $mod;
        my $artval = doubleQuote(makeArtFileName($fwout{$mod}, $seq));
        print $fh  "$artkey : $artval\n"
            or die "setOutputFileNames(): error printing to output file: $!\n";
        push @fcloutkeys, $artkey;
    }

    return \@fcloutkeys;
}
#----------------------------------------------------------------
# Generated part common to EmptySource and RootInput cases
sub printCommonTrailer($$$) {
    my ($fh, $fclinkeys, $fcloutkeys) = @_;

    print $fh
        "mu2emetadata.mc.generator_type: \"$generator_type\"\n",
        "mu2emetadata.mc.simulation_stage: $simulation_stage\n",
        "mu2emetadata.mc.primary_particle: \"$primary_particle\"\n",
        "mu2emetadata.fcl.inkeys: [ ", join(", ", map  { doubleQuote($_) } @$fclinkeys ) ," ]\n",
        'mu2emetadata.fcl.outkeys: [ ', join(', ',map  { doubleQuote($_) } @$fcloutkeys), " ]\n",
        "# End code added by generate_fcl:\n",
        "#----------------------------------------------------------------\n"
        or die "printCommonTrailer(): error printing to output file: $!\n";
}
#================================================================
if($srctype eq 'EmptyEvent') {

    foreach my $k (@emptySourceArgs) {
        (defined $opt{$k} and $opt{$k} ne '' )
            or die "Error: --$k must be specified and nonempty for EmptySource fcl files.  Try the --help option.\n";
    }

    foreach my $k (@fileInputsArgs) {
        die "Error: --$k is not compatible with EmtpySource fcl file.  Try the --help option.\n"
            if(defined $opt{$k});
    }

    for(my $i = 0; $i < $opt{'njobs'}; ++$i) {
        my $subrun = $i + $opt{'first-subrun'};

        my $run = $opt{'run-number'};

        my $seq = sprintf "%06i_%08i", $run, $subrun;
        my $fn =  "cnf.$dsowner.$opt{description}.$dsconf.$seq.fcl";

        open( my $fh,  '>', $fn ) or die "error opening output file $fn: $!\n";

        addAuxInPrologs($fh, \@auxin_specs);

        # Copy the content of the input template fcl.
        open(my $templfh, '<', $templatefile) or die "Can not open \"$templatefile\" $!\n";
        while(my $line = <$templfh>) {
            print $fh $line
                or die "Error printing to output file: $!\n";
        }

        print $fh
            "\n#----------------------------------------------------------------\n",
            "# Code added by generate_fcl:\n"
            or die "Error printing to output file: $!\n";

        addEventID($fh, $run, $subrun, $opt{'events-per-job'});
        addRandomSeed($fh, \%usedSeeds) if $needRandomSeeds;

        my @fclinkeys;
        push @fclinkeys, generateKeysForLocals($fh, \@auxin_specs);
        push @fclinkeys, addAuxInEpilogs($fh,\@auxin_specs);

        my $fcloutkeys = setOutputFileNames($fh, $seq);
        printCommonTrailer($fh, \@fclinkeys, $fcloutkeys);
    }

}
elsif($srctype eq 'RootInput') {

    foreach my $k (@fileInputsArgs) {
        (defined $opt{$k} and $opt{$k} ne '' )
            or die "Error: --$k must be specified and nonempty for RootInput fcl files.  Try the --help option.\n";
    }

    foreach my $k (@emptySourceArgs) {
        die "Error: --$k is not compatible with RootInput fcl files.  Try the --help option.\n"
            if(defined $opt{$k});
    }

    my $inputSourceList = $opt{'inputs'};
    open(my $insrcfh, '<', $inputSourceList) or die "Can not open input file \"$inputSourceList\": $!\n";

    while(my @chunk = getNextInputListChunk($insrcfh, $opt{'merge-factor'})) {

        my $seq = extractASequencer(\@chunk);
        my $fn =  "cnf.$dsowner.$opt{description}.$dsconf.$seq.fcl";

        open( my $fh,  '>', $fn ) or die "error opening output file $fn: $!\n";

        addAuxInPrologs($fh, \@auxin_specs);

        # Copy the content of the input template fcl.
        open(my $templfh, '<', $templatefile) or die "Can not open \"$templatefile\" $!\n";
        while(my $line = <$templfh>) {
            print $fh $line
                or die "Error printing to output file: $!\n";
        }

        print $fh
            "\n#----------------------------------------------------------------\n",
            "# Code added by generate_fcl:\n"
            or die "Error printing to output file: $!\n";

        addRandomSeed($fh, \%usedSeeds) if $needRandomSeeds;

        my @fclinkeys;

        # Set input file names
        push @fclinkeys, addInputFileNames($fh, "source.fileNames", \@chunk);

        push @fclinkeys, generateKeysForLocals($fh, \@auxin_specs);
        push @fclinkeys, addAuxInEpilogs($fh, \@auxin_specs);

        my $fcloutkeys = setOutputFileNames($fh, $seq);
        printCommonTrailer($fh, \@fclinkeys, $fcloutkeys);

        close($fh) or die "Can not close file \"$fn\": $!\n";
    }

}
else {
    die "Error: unknown source.module_type = $srctype\n";
}


#================================================================
# Produce a generic json file for upload of generated fcl files to SAM

my $jsonfilename = "generic.$dsowner.$opt{description}.$dsconf.json";
open( my $json,  '>', $jsonfilename ) or die "error opening output file $jsonfilename: $!\n";
print $json <<EOF
{
    "mc.generator_type": "$generator_type",
    "mc.simulation_stage": $simulation_stage,
    "mc.primary_particle": "$primary_particle"
}
EOF
    or die "Error printing to json file: $!\n";

close($json) or die "Can not close file \"$jsonfilename\": $!\n";

#================================================================
# Dump a list of all previously used seeds: the inputs list plus those
# we've generated in this invocation.  This file will be convenient to
# have if we want to add more statistics.

my ($outseedfh, $outseedfn) = tempfile("seeds.$dsowner.$opt{description}.$dsconf.XXXX", SUFFIX => '.txt');
for my $seed (sort {$a <=> $b} keys %usedSeeds) {
    print $outseedfh $seed, "\n"
        or die "Error printing the seeds: $!\n";
}

close($outseedfh) or die "Can not close file \"$outseedfn\": $!\n";

#================================================================

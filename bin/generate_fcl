#!/usr/bin/perl -w
#
# A.Gaponenko, 2015
#

use autodie;
use Getopt::Long;
use File::Basename;
use File::Copy;
use English qw( -no_match_vars ) ; # Avoids regex performance penalty

use Data::Dumper; # for debugging

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage: 
	$self \\
	 --description=<string> --config-version=<string> \\
         { --inputs=<list-file-name> --merge-factor=<int> |\\
	   --run-number=<int> --first-subrun=<int> \\
	   --events-per-job=<int> --njobs=<int> }\\
	 [--user=<string>] \\
	 [--auxinput=[numFiles:]<fclVarName>:<filelist>] \\
	 [--verbose] [--help] \\
	 template-fcl-file

That will write --njobs fcl files to the current directory.  File
names will be constructed using --description, --config-version, and
other pieces of information according to the Mu2e convention
http://mu2e.fnal.gov/atwork/computing/tapeUpload.shtml
Note that the name of each file in the Mu2e data handling system must
be unique.

The --auxinput option sets the given fcl file variable so that it
points to the files in the given filelist.  If numFiles is specified,
only the given number of randomly selected files from the list are
used, rather than the complete list.  The --fclinput option can be
repeated several times, the effect is cumulative.  If fclVarName
starts with the '\@' sign, it will generate a BEGIN_PROLOG/END_PROLOG
block with a fclVarName definition, which should be referred to using
the \@local::fclVarName syntax in the template fcl file.  If the
variable name does not start with the '\@' sign, an assignment to that
variable will be appended to the user fcl file.

If --user is not specified, the current username will be used.

The square brackets [] above denote optional settings, and
{alternative1|alternative2} constructs denote mutually exclusive
alternatives.  All option names may be abbreviates as long as this is
unambiguous.  (For example, '--verbose' and '--verb' mean the same
thing.)

EOF
}

#================================================================
# constant strings used in more than one place

use constant fclkey_SeedService => 'services.user.SeedService';
use constant fclkey_TFileServiceFN => 'services.TFileService.fileName';
use constant fclkey_outModFMT => 'outputs.%s.fileName';

use constant outputfile_owner => 'MU2EGRIDDSOWNER';
use constant outputfile_conf => 'MU2EGRIDDSCONF';

#================================================================
sub checkParameterValues($$) {
    my ($opt, $list) = @_;
    foreach my $a (@$list) {
	die "Error: parameter $a must be specified\n" unless defined $$opt{$a};
	my $val = $$opt{$a};
	die "Invalid value of parameter $a = '$val'"
	    unless $val =~ /^\w[-\w]*$/;
    }
}

sub makeNtsFileName($$) {
    my ($template, $newseq) = @_;

    # data_tier.owner.description.configuration.sequencer.file_format
    my ($tier, $owner, $description, $conf, $seq, $ext, $extra) = split(/\./, $template);

    die "Error parsing histo file name $template: too many fields\n" if defined $extra;
    die "Error parsing histo file name $template: too few fields\n" if not defined $ext;
    die "Error parsing histo file name $template: expect extension .root\n" if $ext ne 'root';
    die "Error parsing histo file name $template: expect data tier nts\n" if $tier ne 'nts';

    return join('.', ('nts', outputfile_owner, $description, outputfile_conf, $newseq, 'root') );
}

sub makeArtFileName($$) {
    my ($template, $newseq) = @_;

    # data_tier.owner.description.configuration.sequencer.file_format
    my ($tier, $owner, $description, $conf, $seq, $ext, $extra) = split(/\./, $template);

    die "Error parsing art file name $template: too many fields\n" if defined $extra;
    die "Error parsing art file name $template: too few fields\n" if not defined $ext;
    die "Error parsing art file name $template: expect extension .art\n" if $ext ne 'art';

    die "Error parsing art file name $template: unknown data tier $tier\n"
	unless grep( /^$tier$/, ('sim', 'mix', 'dig', 'mcs') );

    return join('.', ($tier, outputfile_owner, $description, outputfile_conf, $newseq, 'art') );
}

#================================================================
sub addEventID($$$$) {
    my ($fh, $run, $subrun, $maxEvents) = @_;
    print $fh "source.firstRun: $run\n";
    print $fh "source.firstSubRun: $subrun\n";
    print $fh "source.maxEvents: $maxEvents\n";
}

sub addRandomSeed($) {
    my ($fh) = @_;
    my $maxUniqueEngines = 20;


    # art's RandomNumberGenerator_service restrict seeds to
    # not exceed 900000000.   Not clear if zero seed is OK
    # so we'll use a non-negative number up to the max.
    # Should leave space for SeedService to increment, thus
    # need to account for maxUniqueEngines.
    my $seedlimit= 900000000 - $maxUniqueEngines + 1;

    my $seed=0;
    my $count = 0;
    open(my $rndfh, '<', '/dev/urandom') or die "Error opening input file /dev/urandom: $!\n";
    do {
	my $recsize = 4; # bytes
	my $binseed = 0;
	read($rndfh, $binseed, $recsize) == $recsize or die "Error reading from /dev/urandom: $!\n";
	my $inseed = unpack '%32L', $binseed;
	$seed = $inseed % $seedlimit;
    } until $seed;

    print $fh fclkey_SeedService . ".policy:  autoIncrement\n";
    print $fh fclkey_SeedService . ".maxUniqueEngines: $maxUniqueEngines\n";
    print $fh fclkey_SeedService . ".baseSeed: $seed\n";
}

#================================================================
my $defaultUser = getpwuid($EFFECTIVE_USER_ID);
my %opt = ('user' =>  $defaultUser, 'verbose' => 0, 'help' => 0);

# Process command line opts.
GetOptions(\%opt,
	   'description=s',
	   'config-version=s',
	   'generator-type=s',
	   'simulation-stage=i',
	   'primary-particle=s',
	   'inputs=s',
	   'merge-factor=i',
	   'run-number=i',
	   'first-subrun=i',
	   'events-per-job=i',
	   'njobs=i',
	   'user=s',
	   'help',
	   'verbose',
    ) 
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

my $verbose = $opt{'verbose'};
print "Final set of options:\n", Dumper( \%opt ), "\n"
    if($verbose);

die "A single non-option arg must specify a template file. Try the --help option.\n"
    unless $#ARGV == 0;

my $templatefile = $ARGV[0];

#----------------------------------------------------------------
# Set up the environment and extract info from the input fcl file
$ENV{'FHICL_FILE_PATH'} = 
    defined($ENV{'FHICL_FILE_PATH'}) ?
    ".:$ENV{'FHICL_FILE_PATH'}"
    : ".";

my $srctype = `fhicl-getpar --string source.module_type $templatefile`;
if($?) {
    die "Error running fhicl-getpar to determine source.module_type.\n";
}
chomp $srctype;
print "Got srctype = $srctype\n" if $verbose;

# optional TFileService output
my $ntscmd = "fhicl-getpar --string ".fclkey_TFileServiceFN." $templatefile 2>/dev/null";
my $ntsout = `$ntscmd`;
chomp $ntsout;
print "Got ntsout = $ntsout\n" if $verbose;

# optional .art output files
my @outmods = `fhicl-getpar --keys outputs $templatefile 2>/dev/null`; 
chomp @outmods;
print "Got outmods = @outmods\n" if $verbose;
my %fwout;
foreach my $mod (@outmods) {
    my $cmd = sprintf "fhicl-getpar --string ".fclkey_outModFMT." $templatefile 2>/dev/null", $mod;
    my $outfile = `$cmd`;
    if($?) {
	die "Error: no fileName for outputs.$mod\n";
    }
    chomp $outfile;;
    $fwout{$mod} = $outfile;
    print "$mod => $outfile\n" if $verbose;
}

# Determine whether SeedService is present: should we generate random seeds?
my $seedcmd = "fhicl-getpar --keys ".fclkey_SeedService." $templatefile 2>/dev/null";
my @seedout = `$seedcmd`; chomp @seedout;
my $needRandomSeeds = $? ? 0 : 1;
print "needRandomSeeds = $needRandomSeeds because got @seedout\n" if $verbose;

#----------------------------------------------------------------
# These arguments must always be provided

checkParameterValues(\%opt,
		     ['user',
		      'config-version',
		      'description',
		      'generator-type',
		      'simulation-stage',
		      'primary-particle'
		     ]);

my $user = $opt{'user'};
my $ver = $opt{'config-version'};

my $generator_type = $opt{'generator-type'};
my $simulation_stage = $opt{'simulation-stage'};
my $primary_particle = $opt{'primary-particle'};

# The set of required args depends on the fcl: e.g s1 needs run
# and subrun numbers but s2 does not, and can not use them.

my @emptySourceArgs = ('run-number', 'first-subrun', 'events-per-job', 'njobs');
my @fileInputsArgs = ('inputs', 'merge-factor');

if($srctype eq 'EmptyEvent') {

    foreach my $k (@emptySourceArgs) {
	(defined $opt{$k} and $opt{$k} ne '' )
	    or die "Error: --$k must be specified and nonempty for EmptySource fcl files.  Try the --help option.\n";
    }

    foreach my $k (@fileInputsArgs) {
	die "Error: --$k is not compatible with EmtpySource fcl file.  Try the --help option.\n"
	    if(defined $opt{$k});
    }

    for(my $i = 0; $i < $opt{'njobs'}; ++$i) {
	my $subrun = $i + $opt{'first-subrun'};

	my $run = $opt{'run-number'};

	my $seq = sprintf "%08i_%06i", $run, $subrun;
	my $fn =  "cnf.$user.$opt{description}.$ver.$seq.fcl";
	
	open( my $fh,  '>', $fn ) or die "error opening output file $fn: $!\n";
	# print "$fn\n";
	copy($templatefile, $fh) or die "error copying $templatefile to $fn: $!\n";

	print $fh "\n#----------------------------------------------------------------\n";
	print $fh "# Code added by generate_fcl:\n";

	print $fh "mu2emetadata.mc.generator_type: $generator_type\n";
	print $fh "mu2emetadata.mc.simulation_stage: $simulation_stage\n";
	print $fh "mu2emetadata.mc.primary_particle: $primary_particle\n";

	my $histval = makeNtsFileName($ntsout, $seq);
	print $fh  fclkey_TFileServiceFN .": \"$histval\"\n" ;

	foreach my $mod (@outmods) {
	    my $artkey = sprintf fclkey_outModFMT, $mod;
	    my $artval = makeArtFileName($fwout{$mod}, $seq);
	    print $fh  "$artkey : \"$artval\"\n" ;
	}

	addRandomSeed($fh) if $needRandomSeeds;
	addEventID($fh, $run, $subrun, $opt{'events-per-job'});
    }

}
elsif($srctype eq 'RootInput') {
    die "RootInput mode is not implemented";
}
else {
    die "Error: unknown source.module_type = $srctype\n";
}

#================================================================
# Produce a generic json file for upload of generated fcl files to SAM

my $jsonfilename = "generic.$user.$opt{description}.$ver.json";
open( my $json,  '>', $jsonfilename ) or die "error opening output file $jsonfilename: $!\n";
print $json <<EOF
{
    "mc.generator_type": "$generator_type",
    "mc.simulation_stage": $simulation_stage,
    "mc.primary_particle": "$primary_particle"
}
EOF

#================================================================

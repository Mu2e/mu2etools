#!/usr/bin/perl -w
#
# A.Gaponenko, 2015
#

use autodie;
use Getopt::Long;
use File::Basename;
use File::Copy;
use File::Temp qw/tempfile/;
use English qw( -no_match_vars ) ; # Avoids regex performance penalty

use Data::Dumper; # for debugging

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage: 
	$self \\
	 --description=<string> --dsconf=<string> \\
	 [--dsowner=<string>] \\
         { --inputs=<list-file-name> --merge-factor=<int> |\\
	   --run-number=<int> --first-subrun=<int> \\
	   --events-per-job=<int> --njobs=<int> }\\
	 [--old-seeds=<seeds-file-name>] \\
	 [--auxinput=[numFiles:]<fclVarName>:<filelist>] \\
	 [--verbose] [--help] \\
	 template-fcl-file

That will write --njobs fcl files to the current directory.  File
names will be constructed using --description, --dsconf, and
other pieces of information according to the Mu2e convention
http://mu2e.fnal.gov/atwork/computing/tapeUpload.shtml
Note that the name of each file in the Mu2e data handling system must
be unique. If --dsowner is not specified, the current username
will be used.

The --old-seeds option points to a text file with a list of seeds that
should not be used in the current generation.  It is required in case
the fcl file defines services.user.SeedService.  Normally this file
will contain a list of seeds in already existing subruns of this
dataset.  One can specify /dev/null for the initial generation.

The --auxinput option sets the given fcl file variable so that it
points to the files in the given filelist.  If numFiles is specified,
only the given number of randomly selected files from the list are
used, rather than the complete list.  The --fclinput option can be
repeated several times, the effect is cumulative.  If fclVarName
starts with the '\@' sign, it will generate a BEGIN_PROLOG/END_PROLOG
block with a fclVarName definition, which should be referred to using
the \@local::fclVarName syntax in the template fcl file.  If the
variable name does not start with the '\@' sign, an assignment to that
variable will be appended to the user fcl file.

The square brackets [] above denote optional settings, and
{alternative1|alternative2} constructs denote mutually exclusive
alternatives.  All option names may be abbreviates as long as this is
unambiguous.  (For example, '--verbose' and '--verb' mean the same
thing.)

EOF
}

#================================================================
# constant strings used in more than one place

use constant fclkey_SeedService => 'services.user.SeedService';
use constant fclkey_TFileServiceFN => 'services.TFileService.fileName';
use constant fclkey_outModFMT => 'outputs.%s.fileName';

use constant outputfile_owner => 'MU2EGRIDDSOWNER';
use constant outputfile_conf => 'MU2EGRIDDSCONF';

#================================================================
sub checkParameterValues($$) {
    my ($opt, $list) = @_;
    foreach my $a (@$list) {
	die "Error: parameter $a must be specified\n" unless defined $$opt{$a};
	my $val = $$opt{$a};
	die "Invalid value of parameter $a = '$val'"
	    unless $val =~ /^\w[-\w]*$/;
    }
}

sub makeNtsFileName($$) {
    my ($template, $newseq) = @_;

    # data_tier.owner.description.configuration.sequencer.file_format
    my ($tier, $owner, $description, $conf, $seq, $ext, $extra) = split(/\./, $template);

    die "Error parsing histo file name $template: too many fields\n" if defined $extra;
    die "Error parsing histo file name $template: too few fields\n" if not defined $ext;
    die "Error parsing histo file name $template: expect extension .root\n" if $ext ne 'root';
    die "Error parsing histo file name $template: expect data tier nts\n" if $tier ne 'nts';

    return join('.', ('nts', outputfile_owner, $description, outputfile_conf, $newseq, 'root') );
}

sub makeArtFileName($$) {
    my ($template, $newseq) = @_;

    # data_tier.owner.description.configuration.sequencer.file_format
    my ($tier, $owner, $description, $conf, $seq, $ext, $extra) = split(/\./, $template);

    die "Error parsing art file name $template: too many fields\n" if defined $extra;
    die "Error parsing art file name $template: too few fields\n" if not defined $ext;
    die "Error parsing art file name $template: expect extension .art\n" if $ext ne 'art';

    die "Error parsing art file name $template: unknown data tier $tier\n"
	unless grep( /^$tier$/, ('sim', 'mix', 'dig', 'mcs') );

    return join('.', ($tier, outputfile_owner, $description, outputfile_conf, $newseq, 'art') );
}

#================================================================
sub addEventID($$$$) {
    my ($fh, $run, $subrun, $maxEvents) = @_;
    print $fh "source.firstRun: $run\n";
    print $fh "source.firstSubRun: $subrun\n";
    print $fh "source.maxEvents: $maxEvents\n";
}

sub addRandomSeed($$) {
    my ($fh, $usedSeeds) = @_;
    my $maxUniqueEngines = 20;

    # art's RandomNumberGenerator_service restrict seeds to
    # not exceed 900000000.   Not clear if zero seed is OK
    # so we'll use a non-negative number up to the max.
    # Should leave space for SeedService to increment, thus
    # need to account for maxUniqueEngines.
    my $seedlimit= 900000000 - $maxUniqueEngines + 1;

    open(my $rndfh, '<', '/dev/urandom') or die "Error opening input file /dev/urandom: $!\n";

    my $seed=0;
    while(!$seed) {
	my $recsize = 4; # bytes
	my $binseed = 0;
	read($rndfh, $binseed, $recsize) == $recsize or die "Error reading from /dev/urandom: $!\n";
	my $inseed = unpack '%32L', $binseed;
	$seed = $inseed % $seedlimit;

	if($$usedSeeds{$seed}) {
	    print STDERR "Skipping old seed $seed\n";
	    redo;
	}
    }
    $$usedSeeds{$seed} = 1;

    print $fh fclkey_SeedService . ".policy:  autoIncrement\n";
    print $fh fclkey_SeedService . ".maxUniqueEngines: $maxUniqueEngines\n";
    print $fh fclkey_SeedService . ".baseSeed: $seed\n";
}

#================================================================
my $defaultUser = getpwuid($EFFECTIVE_USER_ID);
my %opt = ('dsowner' =>  $defaultUser, 'verbose' => 0, 'help' => 0);

# Process command line opts.
GetOptions(\%opt,
	   'description=s',
	   'dsconf=s',
	   'generator-type=s',
	   'simulation-stage=i',
	   'primary-particle=s',
	   'inputs=s',
	   'merge-factor=i',
	   'run-number=i',
	   'first-subrun=i',
	   'events-per-job=i',
	   'njobs=i',
	   'old-seeds=s',
	   'dsowner=s',
	   'help',
	   'verbose',
    ) 
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

my $verbose = $opt{'verbose'};
print "Final set of options:\n", Dumper( \%opt ), "\n"
    if($verbose);

die "A single non-option arg must specify a template file. Try the --help option.\n"
    unless $#ARGV == 0;

my $templatefile = $ARGV[0];

#----------------------------------------------------------------
# Set up the environment and extract info from the input fcl file
$ENV{'FHICL_FILE_PATH'} = 
    defined($ENV{'FHICL_FILE_PATH'}) ?
    ".:$ENV{'FHICL_FILE_PATH'}"
    : ".";

my $srctype = `fhicl-getpar --string source.module_type $templatefile`;
if($?) {
    die "Error running fhicl-getpar to determine source.module_type.\n";
}
chomp $srctype;
print "Got srctype = $srctype\n" if $verbose;

# optional TFileService output
my $ntscmd = "fhicl-getpar --string ".fclkey_TFileServiceFN." $templatefile 2>/dev/null";
my $ntsout = `$ntscmd`;
chomp $ntsout;
print "Got ntsout = $ntsout\n" if $verbose;

# optional .art output files
my @outmods = `fhicl-getpar --keys outputs $templatefile 2>/dev/null`; 
chomp @outmods;
print "Got outmods = @outmods\n" if $verbose;
my %fwout;
foreach my $mod (@outmods) {
    my $cmd = sprintf "fhicl-getpar --string ".fclkey_outModFMT." $templatefile 2>/dev/null", $mod;
    my $outfile = `$cmd`;
    if($?) {
	die "Error: no fileName for outputs.$mod\n";
    }
    chomp $outfile;;
    $fwout{$mod} = $outfile;
    print "$mod => $outfile\n" if $verbose;
}

# Determine whether SeedService is present: should we generate random seeds?
my $seedcmd = "fhicl-getpar --keys ".fclkey_SeedService." $templatefile 2>/dev/null";
my @seedout = `$seedcmd`; chomp @seedout;
my $needRandomSeeds = $? ? 0 : 1;
print "needRandomSeeds = $needRandomSeeds because got @seedout\n" if $verbose;

my %usedSeeds;
if($needRandomSeeds) {
    die "A list of random seeds from existing subruns of this dataset must be specified with --old-seeds.\n"
	."Use an empty file for the initial run.\n"
	unless defined $opt{'old-seeds'};

    open(my $oldseeds, '<', $opt{'old-seeds'}) or die "Error opening input file $opt{'old-seeds'}: $!\n";
    while(my $line = <$oldseeds>) {
	chomp $line;
	next if $line eq '';
	die "Error: bad seed '$line'\n" unless $line =~ /^\d+$/;
	$usedSeeds{0 + $line} = 1;
    }
}
elsif(defined $opt{'old-seeds'}) {
    die "Error: the --old-seeds option will not have any effect because fcl config does not use " . fclkey_SeedService . "\n";
}

#----------------------------------------------------------------
# These arguments must always be provided

checkParameterValues(\%opt,
		     ['dsowner',
		      'dsconf',
		      'description',
		      'generator-type',
		      'simulation-stage',
		      'primary-particle'
		     ]);

my $dsowner = $opt{'dsowner'};
my $dsconf = $opt{'dsconf'};

my $generator_type = $opt{'generator-type'};
my $simulation_stage = $opt{'simulation-stage'};
my $primary_particle = $opt{'primary-particle'};

# The set of required args depends on the fcl: e.g s1 needs run
# and subrun numbers but s2 does not, and can not use them.

my @emptySourceArgs = ('run-number', 'first-subrun', 'events-per-job', 'njobs');
my @fileInputsArgs = ('inputs', 'merge-factor');

if($srctype eq 'EmptyEvent') {

    foreach my $k (@emptySourceArgs) {
	(defined $opt{$k} and $opt{$k} ne '' )
	    or die "Error: --$k must be specified and nonempty for EmptySource fcl files.  Try the --help option.\n";
    }

    foreach my $k (@fileInputsArgs) {
	die "Error: --$k is not compatible with EmtpySource fcl file.  Try the --help option.\n"
	    if(defined $opt{$k});
    }

    for(my $i = 0; $i < $opt{'njobs'}; ++$i) {
	my $subrun = $i + $opt{'first-subrun'};

	my $run = $opt{'run-number'};

	my $seq = sprintf "%08i_%06i", $run, $subrun;
	my $fn =  "cnf.$dsowner.$opt{description}.$dsconf.$seq.fcl";
	
	open( my $fh,  '>', $fn ) or die "error opening output file $fn: $!\n";
	# print "$fn\n";
	copy($templatefile, $fh) or die "error copying $templatefile to $fn: $!\n";

	print $fh "\n#----------------------------------------------------------------\n";
	print $fh "# Code added by generate_fcl:\n";

	print $fh "mu2emetadata.mc.generator_type: $generator_type\n";
	print $fh "mu2emetadata.mc.simulation_stage: $simulation_stage\n";
	print $fh "mu2emetadata.mc.primary_particle: $primary_particle\n";

	my $histval = makeNtsFileName($ntsout, $seq);
	print $fh  fclkey_TFileServiceFN .": \"$histval\"\n" ;

	foreach my $mod (@outmods) {
	    my $artkey = sprintf fclkey_outModFMT, $mod;
	    my $artval = makeArtFileName($fwout{$mod}, $seq);
	    print $fh  "$artkey : \"$artval\"\n" ;
	}

	addRandomSeed($fh, \%usedSeeds) if $needRandomSeeds;
	addEventID($fh, $run, $subrun, $opt{'events-per-job'});
    }

}
elsif($srctype eq 'RootInput') {
    die "RootInput mode is not implemented";
}
else {
    die "Error: unknown source.module_type = $srctype\n";
}

#================================================================
# Produce a generic json file for upload of generated fcl files to SAM

my $jsonfilename = "generic.$dsowner.$opt{description}.$dsconf.json";
open( my $json,  '>', $jsonfilename ) or die "error opening output file $jsonfilename: $!\n";
print $json <<EOF
{
    "mc.generator_type": "$generator_type",
    "mc.simulation_stage": $simulation_stage,
    "mc.primary_particle": "$primary_particle"
}
EOF
    ;

#================================================================
# Dump a list of all previously used seeds: the inputs list plus those
# we've generated in this invocation.  This file will be convenient to
# have if we want to add more statistics.

my ($outseedfh, $outseedfn) = tempfile("seeds.$dsowner.$opt{description}.$dsconf.XXXX", SUFFIX => '.txt');
for my $seed (sort {$a <=> $b} keys %usedSeeds) {
    print $outseedfh $seed, "\n";
}

#================================================================

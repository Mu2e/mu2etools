#!/usr/bin/perl -w
#
# A.Gaponenko, 2015
#

use autodie;
use Getopt::Long;
use Digest;
use File::Basename;
use File::Copy;
use File::Path qw/make_path/;
use File::Temp qw/tempfile/;
use English qw( -no_match_vars ) ; # Avoids regex performance penalty

use Mu2eFilename;

use Data::Dumper; # for debugging

# information from an --auxinput specification (same as mu2eart's --fclin spec)
# listFileName is the name of the file specified on cmdline,
# filenames is the content of that file
# prolog==1 requests to place fcl defs in a BEGIN_PROLOG/END_PROLOG block.
use Class::Struct Mu2eAuxInSpec =>
    [numFilesPerJob=>'$', fclkey=>'$', prolog=>'$', listFileName=>'$', filenames=>'*@',
     # @rsr is a work area to keep "resampling refs": each element is a reference
     # to a different entry in @filenames.  sampleFileNames() draws random
     # refs from @rsr, and removes them from the array.  If there are not enough
     # entries in @rsr to generate a set of filenames for the next fcl file,
     # @rsr is reset to contain a complete set of @filenames refs again.
     rsr=>'@'
    ];

#================================================================
sub usage() {
    my $self = basename($0);
    return <<EOF
Usage:
        $self \\
         --description=<string> --dsconf=<string> \\
         [--dsowner=<string>] \\
         { --inputs=<list-file-name> --merge-factor=<int> |\\
           --run-number=<int> [--first-subrun=<int>] \\
           --events-per-job=<int> --njobs=<int> }\\
         [--old-seeds=<seeds-file-name>] \\
         [--auxinput=[numFiles:]<fclVarName>:<filelist>] \\
         [--[no]split] \\
         [--split-start=<int> --split-stride=<int> --slit-batch-size=<int>] \\
         [--debug-seed=<int>] \\
         [--verbose] [--help] \\
         template-fcl-file

That will produce --njobs fcl files.  File names will be constructed
using --description, --dsconf, and other pieces of information
according to the Mu2e convention
http://mu2e.fnal.gov/atwork/computing/tapeUpload.shtml
Note that the name of each file in the Mu2e data handling system must
be unique. If --dsowner is not specified, the current username will be
used. (If the script is run by the mu2epro user, the default dsowner
is mu2e.)

The --old-seeds option can be used to provide to a text file with a
list of seeds that should not be used in the current generation.
If SeedService is defined in the template fcl file, generate_fcl
writes out a list of all seeds used in the current invocation merged
with the --old-seeds list, if any.  This output file can be used with
the --old-seeds option if one decides to add statistics to that fcl
dataset later; it is necessary to guarantee that each simulation job
uses a unique random seed.

If adding statistics to an existing fcl dataset, remember to specify
an appropriate --first-subrun in addition to --old-seeds.

The --auxinput option sets the given fcl file variable so that it
points to the files in the given filelist.  If numFiles is specified,
only the given number of randomly selected files from the list are
used, rather than the complete list.  The --fclinput option can be
repeated several times, the effect is cumulative.  If fclVarName
starts with the '\@' sign, it will generate a BEGIN_PROLOG/END_PROLOG
block with a fclVarName definition, which should be referred to using
the \@local::fclVarName syntax in the template fcl file.  Prolog
definitions use the \@protect_ignore: FHiCL bindings, therefore take
precedence over any subsequent re-definitions of the same variable in
the template file.  If the variable name does not start with the '\@'
sign, an assignment to that variable will be appended to the user fcl
file.

With the --nosplit options all the generated files will written into
the current directory.  With the --split option (the default) fcl and
json files will be put into subdirectories named 000 to 999, so that
we do not put too many files into a single directory.  The
subdirectories will be created as needed.  The exact distribution of
files among the subdirectories is controlled by the --split-start
(defautl 0), --split-stride (default 1) and --split-batch-size
(default 1000) parameters.

For each fcl file a matching json file will be produced, suitable to
register the job config with SAM.

The --debug-seed option is used to develop the generate_fcl script
itself.  It allows to obtain a reproducible sequence of pseudorandom
numbers used in the code.

The square brackets [] above denote optional settings, and
{alternative1|alternative2} constructs denote mutually exclusive
alternatives.  All option names may be abbreviates as long as this is
unambiguous.  (For example, '--verbose' and '--verb' mean the same
thing.)

EOF
}

#================================================================
# constant strings used in more than one place

use constant fclkey_SeedService => ( 'services.user.SeedService', 'services.SeedService');
my $seedServiceKey = ''; # will be determined from the input fcl file

use constant fclkey_TFileServiceFN => 'services.TFileService.fileName';
use constant fclkey_outModFMT => 'outputs.%s.fileName';

use constant outputfile_owner => 'MU2EGRIDDSOWNER';
use constant outputfile_conf => 'MU2EGRIDDSCONF';

#================================================================
sub doubleQuote($) {
    my ($fn) = @_;
    return  '"'.$fn.'"';
}

#================================================================
sub checkParameterValues($$) {
    my ($opt, $list) = @_;
    foreach my $a (@$list) {
        die "Error: parameter $a must be specified\n" unless defined $$opt{$a};
        my $val = $$opt{$a};
        die "Invalid value of parameter $a = '$val'"
            unless $val =~ /^\w[-\w]*$/;
    }
}

#================================================================
sub addEventID($$$$) {
    my ($fb, $run, $subrun, $maxEvents) = @_;
    $$fb .=
        "source.firstRun: $run\n" .
        "source.firstSubRun: $subrun\n" .
        "source.maxEvents: $maxEvents\n";
}

sub addRandomSeed($$) {
    my ($fb, $usedSeeds) = @_;
    my $maxUniqueEngines = 20;

    # art's RandomNumberGenerator_service restrict seeds to
    # not exceed 900000000.   Not clear if zero seed is OK
    # so we'll use a non-negative number up to the max.
    # Should leave space for SeedService to increment, thus
    # need to account for maxUniqueEngines.
    my $seedlimit= 900000000 - $maxUniqueEngines + 1;

    my $seed=0;
    while(!$seed) {
        $seed = int(rand($seedlimit));
        if($$usedSeeds{$seed}) {
            print STDERR "Skipping old seed $seed\n";
            redo;
        }
    }
    $$usedSeeds{$seed} = 1;

    $$fb .=
        $seedServiceKey . ".policy:  autoIncrement\n".
        $seedServiceKey . ".maxUniqueEngines: $maxUniqueEngines\n".
        $seedServiceKey . ".baseSeed: $seed\n";
}

#================================================================
sub sampleFileNames($) {
    my ($spec) = @_;

    my $res = [];

    if($spec->numFilesPerJob > 0) {

        die "--auxin requests too many files = ",$spec->numFilesPerJob,
        " for file list ",$spec->listFileName,"\n"
            unless $spec->numFilesPerJob <= 1+@{$spec->filenames};

        # do we have enough entries left?
        if(@{$spec->rsr} <= $spec->numFilesPerJob) {
            # refill @rsr
            for(my $i=0; $i<@{$spec->filenames}; ++$i) {
                push @{$spec->rsr}, $spec->filenames($i);
            }
        }

        for(my $i=0; $i<$spec->numFilesPerJob; ++$i) {
            my $index = int(rand($#{$spec->rsr}));
            push @$res, ${$spec->rsr($index)};
            splice @{$spec->rsr}, $index, 1;
        }
    }
    else {
        # use all files from the input list - no sampling
        push @$res, @{$spec->filenames};
    }

    return $res;
}

#================================================================
sub getNextInputListChunk($$) {
    my ($inputfh, $chunkSize) = @_;
    my @res;
    my $line;
    for(my $count=0; ($count < $chunkSize) and ($line = <$inputfh>); ++$count) {
        chomp($line);
        die "Input file list error: the line is empty or contains white spaces or other non-printable characters: \"$line\"\n"
            unless $line =~ /^\p{IsGraph}+$/;
        push @res, $line;
    }
    return @res;
}

#================================================================
sub extractASequencer($) {
    my ($fnlist) = @_;

    die "extractASequencer() got empty inputs\n"
        unless $#$fnlist > -1;

    my @seqs;
    foreach my $fn (@$fnlist) {
        my  $p = Mu2eFilename->parse(basename($fn));
        push @seqs,$p->sequencer;
    }

    return (sort @seqs)[0];
}
#================================================================
sub addInputFileNames($$$$$) {
    my ($fb, $fclkey,$fclbind, $listref, $parentref) = @_;
    $$fb .= "$fclkey $fclbind [\n" . join(",\n", map  { doubleQuote($_) } @$listref ) . "\n]\n";
    push @$parentref, map  { basename($_) } @$listref;
    return $fclkey;
}

#================================================================
sub addAuxInPrologs($$$) {
    my ($fb, $specs, $parentref) = @_;

    my @fclinkeys;
    foreach my $ai (@$specs) {
        if($ai->prolog) {
            my $sample = sampleFileNames($ai);
            $$fb .= "BEGIN_PROLOG  # by generate_fcl\n";
            push @fclinkeys, addInputFileNames($fb, $ai->fclkey, '@protect_ignore:', $sample, $parentref);
            $$fb .= "END_PROLOG  # by generate_fcl\n\n";
        }
    }
    return @fclinkeys;
}
#================================================================
# fhicl-getpar allows worker node script to query parameter values.
# The names of @local variables are not directly accessible there, we
# need to create a fcl parameter for each @local var in order to get
# information about parents.
sub generateKeysForLocals($$) {
    my ($fb, $specs) = @_;
    my @fclkeys;
    foreach my $ai (@$specs) {
        if($ai->prolog) {
            my $key = 'mu2emetadata.fcl.prolog_values.' . $ai->fclkey;
            $$fb .= $key . ': @local::' . $ai->fclkey . "\n";
            push @fclkeys, $key;
        }
    }
    return @fclkeys;
}

#================================================================
sub addAuxInEpilogs($$$) {
    my ($fb, $specs, $parentref) = @_;

    my @fclinkeys;
    foreach my $ai (@$specs) {
        if(!$ai->prolog) {
            my $sample = sampleFileNames($ai);
            push @fclinkeys, addInputFileNames($fb, $ai->fclkey, ':', $sample, $parentref);
        }
    }
    return @fclinkeys;
}

#================================================================
# execution starts here
my $defaultUser = getpwuid($EFFECTIVE_USER_ID);
$defaultUser =~ s/^mu2epro$/mu2e/; # standard datasets should be owned by "mu2e", not "mu2epro"

my @auxinputStrSpecs;

my $split = 1;
my $split_start = 0;
my $split_stride = 1;
my $split_batch_size = 1000;

my %opt = ('dsowner' =>  $defaultUser,
           'auxinput' => \@auxinputStrSpecs,
           'split' => \$split,
           'split-start' => \$split_start,
           'split-stride' => \$split_stride,
           'split-batch-size' => \$split_batch_size,
           'verbose' => 0,
           'help' => 0);

# Process command line opts.
GetOptions(\%opt,
           'description=s',
           'dsconf=s',
           'dsowner=s',
           'inputs=s',
           'merge-factor=i',
           'run-number=i',
           'first-subrun=i',
           'events-per-job=i',
           'njobs=i',
           'old-seeds=s',
           'auxinput=s',
           'split!',
           'split-start=i',
           'split-stride=i',
           'split-batch-size=i',
           'debug-seed=i',
           'help',
           'verbose',
    )
    or die "\nError processing command line options.\n";

if($opt{'help'}) {
    print usage();
    exit 0;
}

my $verbose = $opt{'verbose'};
print "Final set of options:\n", Dumper( \%opt ), "\n"
    if($verbose);

if(defined $opt{'debug-seed'}) {
    srand($opt{'debug-seed'});
}

die "A single non-option arg must specify a template file. Try the --help option.\n"
    unless $#ARGV == 0;

my $templatefile = $ARGV[0];

#----------------------------------------------------------------
# Set up the environment and extract info from the input fcl file
$ENV{'FHICL_FILE_PATH'} =
    defined($ENV{'FHICL_FILE_PATH'}) ?
    ".:$ENV{'FHICL_FILE_PATH'}"
    : ".";

my $srctype = `fhicl-getpar --string source.module_type $templatefile`;
if($?) {
    die "Error running fhicl-getpar to determine source.module_type.\n";
}
chomp $srctype;
print "Got srctype = $srctype\n" if $verbose;

# optional TFileService output
my $ntscmd = "fhicl-getpar --string ".fclkey_TFileServiceFN." $templatefile 2>/dev/null";
my $ntsoutstr = `$ntscmd`;
chomp $ntsoutstr;
print "Got ntsoutstr = $ntsoutstr\n" if $verbose;
my $ntsfn;
if($ntsoutstr ne '') {
    $ntsfn = Mu2eFilename->parse($ntsoutstr);
    die "Bad histo file name $ntsoutstr: expect extension .root\n" unless $ntsfn->extension eq 'root';
    die "Bad histo file name $ntsoutstr: expect data tier nts\n" unless $ntsfn->tier eq 'nts';
    $ntsfn->owner(outputfile_owner);
    $ntsfn->configuration(outputfile_conf);
}

# optional .art output files
my @outmods = `fhicl-getpar --keys outputs $templatefile 2>/dev/null`;
chomp @outmods;
print "Got outmods = @outmods\n" if $verbose;
my %fwout;
foreach my $mod (@outmods) {
    my $cmd = sprintf "fhicl-getpar --string ".fclkey_outModFMT." $templatefile 2>/dev/null", $mod;
    my $outfile = `$cmd`;
    if($?) {
        die "Error: no fileName for outputs.$mod\n";
    }
    chomp $outfile;
    print "$mod => $outfile\n" if $verbose;
    my $fn = Mu2eFilename->parse($outfile);
    die "Bad output file name $outfile: expect extension .art\n" unless $fn->extension eq 'art';
    $fn->owner(outputfile_owner);
    $fn->configuration(outputfile_conf);
    $fwout{$mod} = $fn;
}

# Determine whether SeedService is present: should we generate random seeds?
foreach my $ss (fclkey_SeedService) {
    next unless $ss;
    my $seedcmd = "fhicl-getpar --keys $ss $templatefile 2>/dev/null";
    my @seedout = `$seedcmd`; chomp @seedout;
    if(@seedout) {
        $seedServiceKey = $ss;
        print "Will use seedServiceKey = $seedServiceKey: got @seedout from the query\n" if $verbose;
        last;
    }
}

my %usedSeeds;
if($seedServiceKey) {
    my $inseedfile = $opt{'old-seeds'} // '/dev/null';

    open(my $oldseeds, '<', $inseedfile) or die "Error opening input file $inseedfile: $!\n";
    while(my $line = <$oldseeds>) {
        chomp $line;
        next if $line eq '';
        die "Error: bad seed '$line'\n" unless $line =~ /^\d+$/;
        $usedSeeds{0 + $line} = 1;
    }
}
elsif(defined $opt{'old-seeds'}) {
    die "Error: the --old-seeds option will not have any effect because fcl config does not use the SeedService\n";
}

#----------------
# Handle the --auxinput options

my @auxin_specs;
foreach my $str (@auxinputStrSpecs) {

    die "Error in an --auxin specification: no ':' in $str\n" unless $str =~ /:/;

    my $numFiles = 0; # the default: unlimited
    my $var;
    my $listfile;
    (my $l1, my $l2) = split(/:/, $str, 2);
    if($l1 =~ /^\d/) {
        die "Invalid numFiles=$l1  in --auxinput=$str\n"
            unless $l1 =~ /^\d+$/;
        $numFiles = $l1;
        die "Error in an --auxin specification: no 'filelist' part in $str\n" unless $l2 =~ /:/;
        ($var, $listfile) = split(/:/, $l2, 2);
    }
    else {
        ($var, $listfile) = ($l1, $l2);
    }

    my @auxfiles;
    open(my $fh, '<', $listfile) or die "Can not open for reading file \"$listfile\": $!\n";
    while(my $line = <$fh>) {
        chomp($line);
        die "Error in file $listfile: the line is empty or contains white spaces or other non-printable characters: \"$line\"\n"
            unless $line =~ /^\p{IsGraph}+$/;

        # Must be a Mu2e file name, as it will become an parent in the
        # provenance record of our output datasets. Check that it
        # satisfies the conventions.
        Mu2eFilename->parse(basename($line));

        push @auxfiles, $line;
    }

    my $prolog = 0;
    $prolog = 1 if($var =~ s/^\@// );

    my $spec = Mu2eAuxInSpec->new(
        numFilesPerJob=>$numFiles,
        fclkey=>$var,
        prolog=>$prolog,
        listFileName=>$listfile,
        filenames=>\@auxfiles,
        );

    push @auxin_specs, $spec;
}

#================================================================
# These arguments must always be provided

checkParameterValues(\%opt,
                     ['dsowner',
                      'dsconf',
                      'description'
                     ]);

my $dsowner = $opt{'dsowner'};
my $dsconf = $opt{'dsconf'};

# The set of required args depends on the fcl: e.g s1 needs run
# and subrun numbers but s2 does not, and can not use them.

my @emptySourceArgs = ('run-number', 'first-subrun', 'events-per-job', 'njobs');
my @fileInputsArgs = ('inputs', 'merge-factor');

#================================================================
sub getSplitSubdirName($) {
    my ($num)= @_;

    my $subdir = $split ?
        sprintf "%03d", ($split_start + $split_stride * int($num / $split_batch_size))  % 1000
        : '.';

    return $subdir;
}

#================================================================
# some generated fcl files are large ( O(100K) ).
# pass their content by reference for efficiency, not because
# this function modifies it.
sub writeSpecificJSON($$$) {
    my ($fn,$fb, $parentref) = @_;

    my $fields = Mu2eFilename->parse(basename($fn));

    my $tier = $fields->tier;
    my $dsowner = $fields->owner;
    my $description = $fields->description;
    my $dsconf = $fields->configuration;
    my $seq = $fields->sequencer;
    my $datasetname = $fields->dataset->dsname;

    my $filesize = length($$fb);
    my $filebase = basename($fn);

    my $dig = Digest->new('SHA-256');
    $dig->add($$fb);
    my $sha256 = $dig->hexdigest;

    my $parentstr = @$parentref ?
        "[\n" . join(",\n", map  { ' 'x8 . doubleQuote($_) } @$parentref ) . "\n    ]"
        : "[]"
        ;

    my $jfn = $fn . ".json";
    open( my $json,  '>', $jfn ) or die "error opening output file $jfn: $!\n";

    print $json <<EOF
{
    "content_status": "good",
    "parents": $parentstr,
    "data_tier": "$tier",
    "dh.configuration": "$dsconf",
    "dh.dataset": "$datasetname",
    "dh.description": "$description",
    "dh.owner": "$dsowner",
    "dh.sequencer": "$seq",
    "dh.sha256": "$sha256",
    "file_format": "fcl",
    "file_name": "$filebase",
    "file_size": $filesize,
    "file_type": "mc",
}
EOF
    or die "Error printing to file $jfn: $!\n";

    close($json) or die "Can not close file \"$jfn\": $!\n";
}

#================================================================
sub setOutputFileNames($$) {
    my ($fb, $seq) = @_;

    my @fcloutkeys; # fcl keys for all output file name

    if(defined $ntsfn) {
        $ntsfn->sequencer($seq);
        my $histval = doubleQuote($ntsfn->basename);
        $$fb .= fclkey_TFileServiceFN .": $histval\n";
        push @fcloutkeys, fclkey_TFileServiceFN;
    }

    foreach my $mod (@outmods) {
        my $artkey = sprintf fclkey_outModFMT, $mod;
        $fwout{$mod}->sequencer($seq);
        my $afn = $fwout{$mod}->basename;
        my $artval = doubleQuote($afn);
        $$fb .= "$artkey : $artval\n";
        push @fcloutkeys, $artkey;
    }

    return \@fcloutkeys;
}
#----------------------------------------------------------------
# Generated part common to EmptySource and RootInput cases
sub printCommonTrailer($$$$) {
    my ($fb, $fclprologkeys, $fclinkeys, $fcloutkeys) = @_;

    $$fb .=
        "mu2emetadata.fcl.prologkeys: [ ". join(", ", map  { doubleQuote($_) } @$fclprologkeys )." ]\n".
        "mu2emetadata.fcl.inkeys: [ ". join(", ", map  { doubleQuote($_) } @$fclinkeys )." ]\n".
        'mu2emetadata.fcl.outkeys: [ '. join(', ',map  { doubleQuote($_) } @$fcloutkeys)." ]\n".
        "# End code added by generate_fcl:\n".
        "#----------------------------------------------------------------\n";
}
#================================================================
if($srctype eq 'EmptyEvent') {

    foreach my $k (@emptySourceArgs) {
        (defined $opt{$k} and $opt{$k} ne '' )
            or ($k eq 'first-subrun')
            or die "Error: --$k must be specified and nonempty for EmptySource fcl files.  Try the --help option.\n";
    }

    foreach my $k (@fileInputsArgs) {
        die "Error: --$k is not compatible with EmtpySource fcl file.  Try the --help option.\n"
            if(defined $opt{$k});
    }

    for(my $i = 0; $i < $opt{'njobs'}; ++$i) {
        my $subrun = $i + ($opt{'first-subrun'} // 0);

        my $run = $opt{'run-number'};

        my $seq = sprintf "%06i_%08i", $run, $subrun;

        my $subdir = getSplitSubdirName($i);
        make_path($subdir);
        die "Error creating directory $subdir: $!\n" unless -d $subdir;

        my $fn =  "$subdir/cnf.$dsowner.$opt{description}.$dsconf.$seq.fcl";

        my $fclfb = ''; # a buffer to accumulate fcl file content
        my @parents;

        my @fclprologkeys;
        push @fclprologkeys, addAuxInPrologs(\$fclfb, \@auxin_specs, \@parents);

        # Copy the content of the input template fcl.
        open(my $templfh, '<', $templatefile) or die "Can not open \"$templatefile\" $!\n";
        while(my $line = <$templfh>) {
            $fclfb .= $line;
        }

        $fclfb .=
            "\n#----------------------------------------------------------------\n".
            "# Code added by generate_fcl:\n";

        addEventID(\$fclfb, $run, $subrun, $opt{'events-per-job'});
        addRandomSeed(\$fclfb, \%usedSeeds) if $seedServiceKey;

        my @fclinkeys;
        push @fclinkeys, addAuxInEpilogs(\$fclfb,\@auxin_specs, \@parents);

        my $fcloutkeys = setOutputFileNames(\$fclfb, $seq);

        generateKeysForLocals(\$fclfb, \@auxin_specs);

        printCommonTrailer(\$fclfb, \@fclprologkeys, \@fclinkeys, $fcloutkeys);

        open( my $fh,  '>', $fn ) or die "error opening output file $fn: $!\n";
        print $fh $fclfb or die "Error printing to fcl file \"$fn\": $!\n";
        close($fh) or die "Can not close file \"$fn\": $!\n";

        writeSpecificJSON($fn, \$fclfb, \@parents);
    }

}
elsif($srctype eq 'RootInput') {

    foreach my $k (@fileInputsArgs) {
        (defined $opt{$k} and $opt{$k} ne '' )
            or die "Error: --$k must be specified and nonempty for RootInput fcl files.  Try the --help option.\n";
    }

    foreach my $k (@emptySourceArgs) {
        die "Error: --$k is not compatible with RootInput fcl files.  Try the --help option.\n"
            if(defined $opt{$k});
    }

    my $inputSourceList = $opt{'inputs'};
    open(my $insrcfh, '<', $inputSourceList) or die "Can not open input file \"$inputSourceList\": $!\n";

    my $num = 0;
    while(my @chunk = getNextInputListChunk($insrcfh, $opt{'merge-factor'})) {

        my $seq = extractASequencer(\@chunk);

        my $subdir = getSplitSubdirName($num++);
        make_path($subdir);
        die "Error creating directory $subdir: $!\n" unless -d $subdir;

        my $fn =  "$subdir/cnf.$dsowner.$opt{description}.$dsconf.$seq.fcl";

        my $fclfb = ''; # a buffer to accumulate fcl file content
        my @parents;

        my @fclprologkeys;
        push @fclprologkeys, addAuxInPrologs(\$fclfb, \@auxin_specs, \@parents);

        # Copy the content of the input template fcl.
        open(my $templfh, '<', $templatefile) or die "Can not open \"$templatefile\" $!\n";
        while(my $line = <$templfh>) {
            $fclfb .= $line;
        }

        $fclfb .=
            "\n#----------------------------------------------------------------\n".
            "# Code added by generate_fcl:\n";

        addRandomSeed(\$fclfb, \%usedSeeds) if $seedServiceKey;

        my @fclinkeys;

        # Set input file names
        push @fclinkeys, addInputFileNames(\$fclfb, "source.fileNames", ':', \@chunk, \@parents);

        push @fclinkeys, addAuxInEpilogs(\$fclfb, \@auxin_specs, \@parents);

        my $fcloutkeys = setOutputFileNames(\$fclfb, $seq);

        generateKeysForLocals(\$fclfb, \@auxin_specs);

        printCommonTrailer(\$fclfb, \@fclprologkeys, \@fclinkeys, $fcloutkeys);

        open( my $fh,  '>', $fn ) or die "error opening output file $fn: $!\n";
        print $fh $fclfb or die "Error printing to fcl file \"$fn\": $!\n";
        close($fh) or die "Can not close file \"$fn\": $!\n";

        writeSpecificJSON($fn, \$fclfb, \@parents);
    }

}
else {
    die "Error: unknown source.module_type = $srctype\n";
}

#================================================================
# Dump a list of all previously used seeds: the inputs list plus those
# we've generated in this invocation.  This file will be convenient to
# have if we want to add more statistics.

if(scalar keys %usedSeeds > 0) {
    my ($outseedfh, $outseedfn) = tempfile("seeds.$dsowner.$opt{description}.$dsconf.XXXX", SUFFIX => '.txt');
    for my $seed (sort {$a <=> $b} keys %usedSeeds) {
        print $outseedfh $seed, "\n"
            or die "Error printing the seeds: $!\n";
    }
    close($outseedfh) or die "Can not close file \"$outseedfn\": $!\n";
}

#================================================================
